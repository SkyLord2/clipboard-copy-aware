<!-- <!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Hello Electron</title>
</head>
<body>
    <h1>Hello World!</h1>
    <p>æ­£åœ¨è¿è¡Œ Electron ç‰ˆæœ¬: <span id="node-version"></span></p>
</body>
</html> -->

<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Clipboard Monitor</title>
    <style>
        body { font-family: sans-serif; padding: 20px; }
        #preview-container { margin-top: 20px; border: 1px solid #ddd; padding: 10px; min-height: 200px; }
        img { max-width: 100%; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        .info { color: #666; margin-bottom: 10px; }
    </style>
</head>
<body>
    <h1>ğŸ“‹ å‰ªè´´æ¿å›¾ç‰‡ç›‘æ§</h1>
    <p>æ­£åœ¨è¿è¡Œ Electron ç‰ˆæœ¬: <span id="node-version"></span></p>
    
    <div id="preview-container">
        <div class="info" id="status-text">ç­‰å¾…æˆªå›¾...</div>
        <img id="clipboard-img" style="display: none;" />
    </div>

    <script>
        // 1. å®šä¹‰ DIB è½¬ BMP çš„æ ¸å¿ƒå‡½æ•°
        function createBmpUrlFromDib(dibData) {
        // æ­¤æ—¶ dibData å·²ç»æ˜¯ Uint8Array äº†ï¼Œç›´æ¥ç”¨
        const buffer = new Uint8Array(dibData);

        if (buffer.length < 40) throw new Error("Data too short");

        const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
        
        // --- BMP æ‹¼æ¥é€»è¾‘ (ä¿æŒä¸å˜) ---
        const biSize = view.getUint32(0, true);
        const biBitCount = view.getUint16(14, true);
        const biCompression = view.getUint32(16, true);
        const biClrUsed = view.getUint32(32, true);

        let offsetToBits = 14 + biSize;
        if (biBitCount <= 8) {
            const paletteCount = biClrUsed === 0 ? (1 << biBitCount) : biClrUsed;
            offsetToBits += paletteCount * 4;
        } else if (biCompression === 3) { 
            offsetToBits += 12; 
        }

        const fileHeader = new Uint8Array(14);
        const fhView = new DataView(fileHeader.buffer);
        fileHeader[0] = 0x42; fileHeader[1] = 0x4D;
        fhView.setUint32(2, 14 + buffer.byteLength, true);
        fhView.setUint32(10, offsetToBits, true);

        const blob = new Blob([fileHeader, buffer], { type: 'image/bmp' });
        return URL.createObjectURL(blob);
    }
        // 2. ç›‘å¬ä¸»è¿›ç¨‹å‘æ¥çš„æ¶ˆæ¯
        // window.electronAPI æ˜¯æˆ‘ä»¬åœ¨ preload.js ä¸­æš´éœ²çš„å¯¹è±¡
        if (window.electronAPI) {
            window.electronAPI.onUpdateImage((info) => {
                // console.log('æ”¶åˆ°æˆªå›¾ä¿¡æ¯:', info);
                
                const img = document.getElementById('clipboard-img');
                const status = document.getElementById('status-text');

                // é‡Šæ”¾ä¹‹å‰çš„ URL å¯¹è±¡ï¼Œé¿å…å†…å­˜æ³„æ¼
                if (img.src) {
                    URL.revokeObjectURL(img.src);
                }

                try {
                    // è½¬æ¢å¹¶æ˜¾ç¤º
                    const imgUrl = createBmpUrlFromDib(info.data);
                    img.src = imgUrl;
                    img.style.display = 'block';
                    
                    status.innerHTML = `
                        <strong>æ¥æºè¿›ç¨‹:</strong> ${info.pname} (PID: ${info.pid})<br/>
                        <strong>æ•°æ®å¤§å°:</strong> ${info.data.length || info.data.byteLength} bytes
                    `;
                } catch (e) {
                    console.error('å›¾ç‰‡è½¬æ¢å¤±è´¥:', e);
                    status.textContent = 'å›¾ç‰‡æ•°æ®è§£æå¤±è´¥';
                }
            });
        } else {
            console.error('electronAPI æœªå®šä¹‰ï¼Œè¯·æ£€æŸ¥ preload.js æ˜¯å¦æ­£ç¡®åŠ è½½');
        }

        // æ˜¾ç¤ºç‰ˆæœ¬å· (åŸæœ‰é€»è¾‘)
        const versionSpan = document.getElementById('node-version');
        if (versionSpan) versionSpan.innerText = process.versions.electron;
    </script>
</body>
</html>